import math
import os
import time
from typing import Any

import numpy as np
from omegaconf import DictConfig, OmegaConf


def pytorch_worker_info(group=None):
    """Return node and worker info for PyTorch and some distributed environments."""
    rank = 0
    world_size = 1
    worker = 0
    num_workers = 1
    if "RANK" in os.environ and "WORLD_SIZE" in os.environ:
        rank = int(os.environ["RANK"])
        world_size = int(os.environ["WORLD_SIZE"])
    else:
        try:
            import torch.distributed

            if torch.distributed.is_available() and torch.distributed.is_initialized():
                group = group or torch.distributed.group.WORLD
                rank = torch.distributed.get_rank(group=group)
                world_size = torch.distributed.get_world_size(group=group)
        except ModuleNotFoundError:
            pass
    if "WORKER" in os.environ and "NUM_WORKERS" in os.environ:
        worker = int(os.environ["WORKER"])
        num_workers = int(os.environ["NUM_WORKERS"])
    else:
        try:
            import torch.utils.data

            worker_info = torch.utils.data.get_worker_info()
            if worker_info is not None:
                worker = worker_info.id
                num_workers = worker_info.num_workers
        except ModuleNotFoundError:
            pass

    return rank, world_size, worker, num_workers


def pytorch_worker_seed(group=None):
    """Compute a distinct, deterministic RNG seed for each worker and node."""
    rank, world_size, worker, num_workers = pytorch_worker_info(group=group)
    return rank * 1000 + worker


def make_seed(*args):
    """
    Generate a seed value based on the hashed values of input arguments.

    This function takes any number of arguments, hashes each argument, and combines them into a single seed value.
    The seed is generated by iteratively multiplying the current seed by 31, adding the hash of the next argument,
    and taking the result modulo 2^31. This ensures the seed stays within the range of a 32-bit integer.

    Args:
        *args: Variable length argument list to be hashed and combined.

    Returns:
        int: The final seed value.
    """
    seed = 0
    for arg in args:
        seed = (seed * 31 + hash(arg)) & 0x7FFFFFFF
    return seed


def truly_random_seed(*args):
    """
    Generate a truly random seed value.

    This function generates a seed value that is as random as possible by using the current process ID, the current
    nanosecond timestamp, and a random 4-byte string generated by the OS, whose randomness comes from the random number
    generator provided by the operating system. These values are passed to the make_seed function to generate the final
    seed value.

    Returns:
        int: A truly random seed value.
    """
    return make_seed(pytorch_worker_seed(), os.getpid(), time.time_ns(), os.urandom(4), *args)


def avg_std(data: list) -> tuple[int, int]:
    avg = sum(data) / len(data)
    std = math.sqrt(sum([(x - avg) ** 2 for x in data]) / (len(data) - 1))
    return round(avg, 3), round(std, 3)


def is_nan(value):
    if value is None:
        return True
    try:
        if isinstance(value, float):
            return np.isnan(value)
        elif isinstance(value, (np.float_, np.float16, np.float32, np.float64)):
            return np.isnan(value)
        else:
            return False
    except TypeError:
        return False


def listdir(path):
    return [f for f in os.listdir(path) if not f.startswith(".")]


def omageconf_safe_update(cfg: DictConfig, key: str, value: Any, merge: bool = True):
    parts = key.split(".")
    for idx in range(1, len(parts)):
        prefix = ".".join(parts[:idx])
        v = OmegaConf.select(cfg, prefix, default=None)
        if v is None:
            break
        if not OmegaConf.is_config(v):
            raise KeyError(f"Trying to update key {key}, but {prefix} is not a config, but has type {type(v)}.")
    OmegaConf.update(cfg, key, value, merge=merge)


def omageconf_safe_update_dict(cfg: DictConfig, _dict: dict, merge: bool = True):
    for k, v in _dict.items():
        omageconf_safe_update(cfg, k, v, merge=merge)
